----------------------------------------------------------------
TODO

ログとか.

このプログラム自体の起動スクリプトの例.
三段階の停止, 起動, 再起動, つまり
  このプログラムが扱っているプログラム
  このプログラム
  OS

ZIP で import export したい！

----------------------------------------------------------------
データベース

あるディレクトリ以下をデータベースとする.
このディレクトリを *dir* とする.
*dir* は起動時に指定する.
絶対パス, または emjed を起動したときのカレントディレクトリを起点
とする相対パスで指定する.
省略すると emjed を起動したときのカレントディレクトリが *dir* と
して使われる.
実行中に切替られる.

データベースは,
コンフィギュレーション, プログラム登録達, ファイル達からなる.

コンフィギュレーションは, 文字列, 数値, 真偽値, 配列,
ハッシュマップ および null によるデータであり,
配列およびハッシュマップは, 階層的に他のデータ型のデータを
格納することができる.

emjed は, 起動時および *dir* が切り替えられた時に *dir*/conf.json
ファイルに格納された JSON 表現をコンフィギュレーションとして読み込む.
文字列, 数値, 真偽値, 配列, ハッシュマップ および null は
それぞれ, JSON の, 文字列, 数値, 真偽値, 配列, オブジェクトおよび
null で表現される.
また, 指定された場合, メモリ中に保持しているコンフィギュレーション
を, *dir*/conf.json ファイルに JSON 形式で書き込む.

コンフィギュレーションの内容は emjed は関知しない.
後述のプログラム達が利用する設定などを自由に構成して良い.

プログラム登録達は, コンフィグレーションと同様の仕組みで,
プログラムの名称, 名前空間, 実行スケジュールなど, プログラムの実行
に関わるデータを保持する.
起動時や *dir* が切り替えられた際に *dir*/prog.json ファイルに格納
された JSON 表現を読み込み, また指定された場合に, メモリ中に保持し
ているプログラム達を, *dir*/prog.json に JSON 形式で書き込む.
ただし, 構造は内部で規定されており, 後述するインターフェイスを通して,
構造を保持しながらデータを閲覧・編集する.

ファイル達, はソースコード, コンパイル済みバイナリなどのライブラリや
プログラムのファイル. リソースとなる HTML, 画像などのファイルである.
前述の *dir*/conf.json, *dir*/prog.json と名称が重ならない限りにおいて
*dir* 以下に自由にファイルを配置し, リソースとしてプログラム登録や
登録されたプログラム内部からアクセスして良い.

データベース全体, コンフィギュレーション, プログラム登録達,
ファイル達にアクセスする方法は二通りある.
ネットワークインターフェイスとライブラリインターフェイスである.

ネットワークインターフェイス.
同ホストまたは同ホストに TCP/IP アクセス可能なホスト上の,
HTTP クライアントから HTTP サーバとして起動している emjed に
アクセスし, データベースの閲覧・編集が可能である.
この命令や応答の内容をネットワークインターフェイスとして規定する.

ライブラリインターフェイス.
データベースに登録されたプログラム達は, ライブラリインターフェイス
を通して, データベースにアクセス可能である.
この命令や応答の内容をライブラリインターフェイスとして規定する.

----------------------------------------------------------------
全般

ネットワークインターフェイス
pwd
cd path
load
save

ライブラリインターフェイス
ldb/pwd
ldb/cd path
ldb/load
ldb/save

----------------------------------------------------------------
コンフィギュレーション

":foo:bar" 式のキーチェインの名前: Qualified Key
[:foo :bar] 式のキーチェインの名前: Key Vector

ネットワークインターフェイス
get qk                -> json-exp
getrec qk             -> json-exp
set qk json-exp       -> "OK"
del qk                -> "OK"
rename sqk dqk        -> "OK"

ライブラリインターフェイス
ldb/get kv            -> native-exp
ldb/getrec kv         -> native-exp
ldb/set kv native-exp -> nil
ldb/del kv            -> nil
ldb/rename skv dkv    -> nil

----------------------------------------------------------------
プログラム登録達

ライブラリインターフェイス
register
  name
  lang
  version
unregister name
view name item value
edit name item
exec name
kill name
ps

プログラムの実行が終わったら,
runnings から削除はいつやる?
ps された時?

先に *prog* がどういう状態にあるべきか考えよう
{:km20-driver
  {:type jar ? clj?
   :version
   :source "src/air12/drivers/{km20.clj,...}"
   :execution "AUTO" | "MANUAL"
   :timing "LOOP" | "ONCE" | "SCHEDULE"
   :wait <- timing = "LOOP" の場合
   :schedule < timing = "ONCE" の場合
  }

一回実行
  起動時に一回だけやりたい処理や
  サーバの起動など

ループ実行
  実行が終わったらウェイトで指定されたミリ秒だけまって順に実行.
  インターバルではなく, 実行が終わってから次の実行までの待ち時間
  で指定するので, 周期実行ではない.

スケジュール実行
  分 0-59
  時 0-23
  日 1-31
  月 1-12
  曜日 0-7 (0および7は日曜日)
  それぞれ
    カンマ区切りで複数指定    0,10
    ハイフン区切りで範囲指定  1-5
    カンマとハイフン共存
    *
これだと最終金曜日とか, 月末とかできない.
cron の場合 cron エントリは毎週金曜実行して,
そのエントリの中で test と date を駆使して最終金曜かどうか
(7日後が次の月かどうか) 識別したりしている.

----------------------------------------------------------------
ファイル達

ネットワークインターフェイス
flist
fget path
fput path length "\r\n" binary "\r\n"
fdel path
frename spath dpath

ライブラリインターフェイス
ldb/flist          -> a list
ldb/fget path      -> body
ldb/fput path body -> "OK"
ldb/fdel path      -> "OK"
ldb/frename spath dpath -> "OK"

----------------------------------------------------------------
JSON は RFC 4627 
http://datatracker.ietf.org/doc/rfc4627/
で規定される国際標準である.
